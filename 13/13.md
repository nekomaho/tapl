# TaPL Chapter 13

## 13.4 ストア型付け
### memo
- `l` ストアドでの位置
- `:=` 破壊的代入
- `Γ` 型付け文脈。変数とその型の列であり、「コンマ」演算子はΓの右に新しい束縛を加えて拡張する。
- `Γ |- t:T` 「閉じた項tは型付文脈Γの仮定の元で型Tを持つ」
- `Γ | μ  |- t:T` 「閉じた項tは型付文脈Γかつストアμの仮定の元で型Tを持つ」 `,`でも同じ意味だけど、そもそもΓで`,`は使用しているから`|`を使っているんじゃないかという話だった。


### 演習 13.4.1.
#### q
- 具体的な項で、評価によってこの例の循環的なストアを作るものはあるか。

#### a
わからんかった

`let r1 = ref (λx:Nat.0) in`  
`let r2 = ref (λx:Nat.(!r1)x) in`  
`(r1 := (λx:Nat.(!r2)x));`  
`r2);`  

最初の行は「式 `ref (λx:Nat.0)` を評価し、その結果の値に名前r1を束縛した状態で `let r2 = ref (λx:Nat.(!r1)x) in (r1 := (λx:Nat.(!r2)x)); r2);` を評価せよ」という意味になる。
`ref (λx:Nat.0)` で新しいセルへ初期値0を与える形になっている。つまりr1はどこかのセルに0が割り当てられている。
言い換えると r1は 0への参照を持っていることになる。
`!r1;`
`0 : Nat`

次の行は上記を加味した上で、「式 `ref (λx:Nat.(!r1)x)`を評価し、その結果の値に名前r2を束縛した状態で `(r1 := (λx:Nat.(!r2)x)); r2):` を評価せよ」 という意味になる。

`!r1` は 0なので、簡略すると `ref (λx:Nat.(0)x)` になる。
つまりこの時点ではr2はどこかのセルに `λx:Nat.x` が割り当てられてる。
言い換えると、r2は `λx:Nat.x`への参照を持っていることになる。

次の行と最後の行は `(r1 := (λx:Nat.(!r2)x)); r2);` で、r1に対して破壊的代入を行っている。
この段階で上記の `r1` の型を導出する為には `(λx:Nat.(!r2)x)`が必要になる。
つまり `λx:Nat.(λx:Nat.x)x)`が `!r1`となる。つまり型は`Nat` になる。
ここで`r2`の型を算出しようとすると、 `ref (λx:Nat.(!r1)x)` の計算が必要となるが、 `!r1` は `(λx:Nat.(!r2)x)` のため、循環参照となってしまう。


#### 分からんこと
- `r2`の型を評価するときだけ問題になるのか？ ストアの前半(r1への破壊的代入)の評価は問題ないのかがよくわからない。


## 13.5 安全性
### 演習 13.5.2.
#### q
- `Γ | Σ1 |- µ` と `Γ | Σ2 |- µ` とを同時に満 たすように、文脈`Γ、` ストア ` µ`、 および相異なるストア型付け Σ1 と Σ2 を取れるか。

#### a


### 演習 13.5.8.
#### q
- 本章の評価規則は、 正しく型付けされた項に対して正規化可能性を持つか。持つならば証明せよ。持たないならば、正しく型付けされた階乗関数をこの計算体系で書け （数とブール値についての拡張をした上で）。

#### a
